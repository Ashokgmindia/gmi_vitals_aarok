#include <WiFi.h>
#include <HTTPClient.h>
#include <Wire.h>
#include "MAX30105.h"
#include "heartRate.h"
#include <ArduinoJson.h>

// Network Configuration
const char* WIFI_SSID = "Gio Fiber";
const char* WIFI_PASS = "Wewillwin@01";
const char* API_SERVER = "http://192.168.31.62:8000";
String API_ENDPOINT_VITALS = String(API_SERVER) + "/api/vitals";
const char* DEVICE_ID = "esp32_vitals_01";

// Pin Definitions
#define LM35_PIN 34
#define SDA_PIN 21
#define SCL_PIN 22
#define LED_PIN 2  // Built-in LED for status indication

// Sensor Objects
MAX30105 sensor;

// System State Variables
bool sensorOK = false;
bool wifiConnected = false;
int wifiRetryCount = 0;
int httpErrorCount = 0;
unsigned long lastWiFiAttempt = 0;
unsigned long lastSensorRead = 0;
unsigned long lastHeartbeat = 0;

// Sensor Data - Current readings
float tempC = 0.0;
float spo2 = 0.0;
int heartRate = 0;
bool spo2Valid = false;
bool tempValid = false;
bool tempContactDetected = false;

// Sampling State Variables
bool tempSampling = false;
bool fingerSampling = false;
unsigned long tempSamplingStart = 0;
unsigned long fingerSamplingStart = 0;
int tempSampleCount = 0;
int fingerSampleCount = 0;

// Maximum values during 5-second sampling
float maxTempC = 0.0;
float maxSpO2 = 0.0;
int maxHeartRate = 0;
bool validTempSample = false;
bool validFingerSample = false;

// Constants
const int MAX_WIFI_RETRIES = 3;
const int MAX_HTTP_RETRIES = 3;
const int WIFI_TIMEOUT = 10000;  // 10 seconds
const int HTTP_TIMEOUT = 5000;   // 5 seconds
const int SENSOR_READ_INTERVAL = 100;  // Read every 100ms for better sampling
const int SAMPLING_DURATION = 5000;    // 5 seconds sampling period
const int HEARTBEAT_INTERVAL = 15000;  // Status every 15 seconds

void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  
  Serial.println("=== ESP32 Health Monitor Starting ===");
  Serial.println("=== 5-Second Sampling Mode ===");
  delay(1000);
  
  // Initialize I2C with error checking
  if (!initializeI2C()) {
    Serial.println("ERROR: I2C initialization failed");
    handleCriticalError("I2C_INIT_FAIL");
  }
  
  // Initialize MAX30105 sensor
  if (!initializeSensor()) {
    Serial.println("WARNING: MAX30105 sensor initialization failed");
    sensorOK = false;
  }
  
  // Initialize temperature sensor
  if (!initializeTemperatureSensor()) {
    Serial.println("WARNING: Temperature sensor initialization failed");
  }
  
  // Connect to WiFi
  connectWiFi();
  
  Serial.println("=== Setup Complete ===");
  Serial.println("Ready for sensor contact detection...");
}

void loop() {
  unsigned long currentTime = millis();
  
  // Check WiFi connection periodically
  checkWiFiConnection();
  
  // Read sensors at specified interval
  if (currentTime - lastSensorRead >= SENSOR_READ_INTERVAL) {
    readAllSensors();
    processSampling(currentTime);
    lastSensorRead = currentTime;
  }
  
  // Send heartbeat status
  if (currentTime - lastHeartbeat >= HEARTBEAT_INTERVAL) {
    sendHeartbeat();
    lastHeartbeat = currentTime;
  }
  
  // Update status LED
  updateStatusLED();
  
  delay(50); // Small delay for system stability
}

bool initializeI2C() {
  Wire.begin(SDA_PIN, SCL_PIN);
  
  // Test I2C bus by scanning for devices
  byte error, address;
  int deviceCount = 0;
  
  Serial.println("Scanning I2C devices...");
  for(address = 1; address < 127; address++) {
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    if (error == 0) {
      Serial.printf("I2C device found at address 0x%02X\n", address);
      deviceCount++;
    }
  }
  
  Serial.printf("SUCCESS: I2C bus initialized, found %d devices\n", deviceCount);
  return true;
}

bool initializeSensor() {
  Serial.println("Initializing MAX30105 sensor...");
  
  if (!sensor.begin(Wire, I2C_SPEED_STANDARD)) {
    Serial.println("ERROR: MAX30105 not found - check wiring");
    return false;
  }
  
  // Configure sensor for better accuracy
  sensor.setup();
  sensor.setPulseAmplitudeIR(0x0A);
  sensor.setPulseAmplitudeRed(0x0A);
  
  // Test sensor reading
  delay(100);
  long testIR = sensor.getIR();
  
  if (testIR >= 0) {
    sensorOK = true;
    Serial.println("SUCCESS: MAX30105 sensor initialized");
    Serial.printf("Initial IR reading: %ld\n", testIR);
    return true;
  } else {
    Serial.println("ERROR: Invalid sensor reading during initialization");
    return false;
  }
}

bool initializeTemperatureSensor() {
  Serial.println("Initializing LM35 temperature sensor...");
  
  analogSetPinAttenuation(LM35_PIN, ADC_11db);
  
  // Test temperature reading
  delay(10);
  int testRaw = analogRead(LM35_PIN);
  float testVoltage = (testRaw / 4095.0f) * 3.3f;
  float testTemp = testVoltage / 0.01f;
  
  if (testRaw >= 0 && testRaw <= 4095) {
    Serial.println("SUCCESS: LM35 temperature sensor initialized");
    Serial.printf("Initial temperature reading: %.1f°C\n", testTemp);
    return true;
  } else {
    Serial.println("ERROR: Invalid temperature sensor reading");
    return false;
  }
}

void connectWiFi() {
  if (wifiConnected || (millis() - lastWiFiAttempt < 5000)) return;
  
  lastWiFiAttempt = millis();
  wifiRetryCount++;
  
  Serial.printf("Attempting WiFi connection (attempt %d/%d)...\n", 
                wifiRetryCount, MAX_WIFI_RETRIES);
  
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  
  unsigned long startTime = millis();
  while (WiFi.status() != WL_CONNECTED && 
         (millis() - startTime < WIFI_TIMEOUT)) {
    delay(500);
    Serial.print(".");
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    wifiRetryCount = 0;
    Serial.printf("\nSUCCESS: WiFi connected to %s\n", WIFI_SSID);
    Serial.printf("IP address: %s\n", WiFi.localIP().toString().c_str());
    Serial.printf("Signal strength: %d dBm\n", WiFi.RSSI());
  } else {
    wifiConnected = false;
    Serial.printf("\nERROR: WiFi connection failed (Status: %d)\n", WiFi.status());
    printWiFiStatus(WiFi.status());
    
    if (wifiRetryCount >= MAX_WIFI_RETRIES) {
      Serial.println("ERROR: Maximum WiFi retry attempts reached");
      wifiRetryCount = 0;
      delay(30000);
    }
  }
}

void printWiFiStatus(wl_status_t status) {
  switch(status) {
    case WL_NO_SHIELD:
      Serial.println("WiFi Error: No WiFi shield present");
      break;
    case WL_IDLE_STATUS:
      Serial.println("WiFi Status: Idle");
      break;
    case WL_NO_SSID_AVAIL:
      Serial.println("WiFi Error: SSID not available");
      break;
    case WL_SCAN_COMPLETED:
      Serial.println("WiFi Status: Scan completed");
      break;
    case WL_CONNECTED:
      Serial.println("WiFi Status: Connected");
      break;
    case WL_CONNECT_FAILED:
      Serial.println("WiFi Error: Connection failed");
      break;
    case WL_CONNECTION_LOST:
      Serial.println("WiFi Error: Connection lost");
      break;
    case WL_DISCONNECTED:
      Serial.println("WiFi Status: Disconnected");
      break;
    default:
      Serial.printf("WiFi Status: Unknown (%d)\n", status);
      break;
  }
}

void checkWiFiConnection() {
  wl_status_t currentStatus = WiFi.status();
  
  if (currentStatus != WL_CONNECTED) {
    if (wifiConnected) {
      Serial.println("WARNING: WiFi connection lost");
      printWiFiStatus(currentStatus);
      wifiConnected = false;
    }
    connectWiFi();
  } else {
    if (!wifiConnected) {
      Serial.println("WiFi connection restored");
    }
    wifiConnected = true;
  }
}

void readAllSensors() {
  // Read temperature sensor (LM35 with contact detection)
  readTemperature();
  
  // Read heart rate and SpO2 sensors (MAX30105 with finger detection)
  if (sensorOK) {
    readHeartRateAndSpO2();
  } else {
    heartRate = 0;
    spo2 = 0.0;
    spo2Valid = false;
  }
}

void readTemperature() {
  int raw = analogRead(LM35_PIN);
  
  if (raw < 0 || raw > 4095) {
    tempValid = false;
    tempContactDetected = false;
    return;
  }
  
  float voltage = (raw / 4095.0f) * 3.3f;
  tempC = voltage / 0.01f;
  
  // Contact detection logic
  if (tempC < 10.0 || tempC > 50.0) {
    tempValid = false;
    tempContactDetected = false;
  } else if (tempC >= 10.0 && tempC < 30.0) {
    tempContactDetected = false;
    tempValid = false;
  } else if (tempC >= 30.0 && tempC <= 50.0) {
    tempContactDetected = true;
    tempValid = true;
  } else {
    tempValid = false;
    tempContactDetected = false;
  }
}

void readHeartRateAndSpO2() {
  long ir = sensor.getIR();
  long red = sensor.getRed();
  
  if (ir < 0 || red < 0) {
    spo2Valid = false;
    return;
  }
  
  if (fingerDetected(ir, red)) {
    heartRate = calcHeartRate(ir);
    spo2 = calcSpO2(red, ir);
    
    if (heartRate >= 30 && heartRate <= 200 && spo2 >= 70.0 && spo2 <= 100.0) {
      spo2Valid = true;
    } else {
      spo2Valid = false;
    }
  } else {
    heartRate = 0;
    spo2 = 0.0;
    spo2Valid = false;
  }
}

void processSampling(unsigned long currentTime) {
  // Handle Temperature Sampling
  if (tempContactDetected && tempValid) {
    if (!tempSampling) {
      // Start temperature sampling
      startTemperatureSampling(currentTime);
    } else {
      // Continue temperature sampling
      continueTemperatureSampling(currentTime);
    }
  } else {
    if (tempSampling) {
      // Stop temperature sampling if contact lost
      stopTemperatureSampling();
    }
  }
  
  // Handle Finger Sampling (SpO2/Heart Rate)
  if (spo2Valid) {
    if (!fingerSampling) {
      // Start finger sampling
      startFingerSampling(currentTime);
    } else {
      // Continue finger sampling
      continueFingerSampling(currentTime);
    }
  } else {
    if (fingerSampling) {
      // Stop finger sampling if finger removed
      stopFingerSampling();
    }
  }
  
  // Print current status
  printCurrentStatus();
}

void startTemperatureSampling(unsigned long currentTime) {
  tempSampling = true;
  tempSamplingStart = currentTime;
  tempSampleCount = 0;
  maxTempC = 0.0;
  validTempSample = false;
  
  Serial.println(">>> STARTING Temperature Sampling (5 seconds)");
  Serial.printf("Initial Temperature: %.1f°C\n", tempC);
}

void continueTemperatureSampling(unsigned long currentTime) {
  tempSampleCount++;
  
  // Track maximum temperature
  if (tempC > maxTempC) {
    maxTempC = tempC;
    validTempSample = true;
  }
  
  unsigned long elapsed = currentTime - tempSamplingStart;
  float progress = (float)elapsed / SAMPLING_DURATION * 100.0;
  
  Serial.printf("TEMP Sampling: %.1f%% - Current: %.1f°C, Max: %.1f°C (Samples: %d)\n", 
                progress, tempC, maxTempC, tempSampleCount);
  
  // Check if 5 seconds completed
  if (elapsed >= SAMPLING_DURATION) {
    completeTemperatureSampling();
  }
}

void completeTemperatureSampling() {
  tempSampling = false;
  
  Serial.println(">>> COMPLETED Temperature Sampling");
  Serial.printf("Final Results - Max Temperature: %.1f°C (from %d samples)\n", 
                maxTempC, tempSampleCount);
  
  if (validTempSample && wifiConnected) {
    sendTemperatureData();
  } else if (!wifiConnected) {
    Serial.println("WARNING: Cannot send temperature data - No WiFi connection");
  }
}

void stopTemperatureSampling() {
  if (tempSampling) {
    tempSampling = false;
    Serial.println(">>> STOPPED Temperature Sampling - Contact lost");
    Serial.printf("Incomplete sampling - Max Temperature so far: %.1f°C\n", maxTempC);
  }
}

void startFingerSampling(unsigned long currentTime) {
  fingerSampling = true;
  fingerSamplingStart = currentTime;
  fingerSampleCount = 0;
  maxSpO2 = 0.0;
  maxHeartRate = 0;
  validFingerSample = false;
  
  Serial.println(">>> STARTING Finger Sampling (5 seconds)");
  Serial.printf("Initial SpO2: %.1f%%, HR: %d BPM\n", spo2, heartRate);
}

void continueFingerSampling(unsigned long currentTime) {
  fingerSampleCount++;
  
  // Track maximum values
  if (spo2 > maxSpO2) {
    maxSpO2 = spo2;
    validFingerSample = true;
  }
  if (heartRate > maxHeartRate) {
    maxHeartRate = heartRate;
    validFingerSample = true;
  }
  
  unsigned long elapsed = currentTime - fingerSamplingStart;
  float progress = (float)elapsed / SAMPLING_DURATION * 100.0;
  
  Serial.printf("FINGER Sampling: %.1f%% - Current: SpO2=%.1f%%, HR=%d - Max: SpO2=%.1f%%, HR=%d (Samples: %d)\n", 
                progress, spo2, heartRate, maxSpO2, maxHeartRate, fingerSampleCount);
  
  // Check if 5 seconds completed
  if (elapsed >= SAMPLING_DURATION) {
    completeFingerSampling();
  }
}

void completeFingerSampling() {
  fingerSampling = false;
  
  Serial.println(">>> COMPLETED Finger Sampling");
  Serial.printf("Final Results - Max SpO2: %.1f%%, Max HR: %d BPM (from %d samples)\n", 
                maxSpO2, maxHeartRate, fingerSampleCount);
  
  if (validFingerSample && wifiConnected) {
    sendFingerData();
  } else if (!wifiConnected) {
    Serial.println("WARNING: Cannot send finger data - No WiFi connection");
  }
}

void stopFingerSampling() {
  if (fingerSampling) {
    fingerSampling = false;
    Serial.println(">>> STOPPED Finger Sampling - Finger removed");
    Serial.printf("Incomplete sampling - Max SpO2: %.1f%%, Max HR: %d BPM\n", maxSpO2, maxHeartRate);
  }
}

bool fingerDetected(long ir, long red) {
  return (ir > 5000 && red > 5000);
}

int calcHeartRate(long ir) {
  int mapped = map(ir % 3000, 0, 3000, 60, 110);
  return constrain(mapped, 30, 200);
}

float calcSpO2(long red, long ir) {
  if (ir == 0) return 0.0;
  
  float r = (float)red / (float)ir;
  float spo2Value = 110.0 - (25.0 * r);
  return constrain(spo2Value, 70.0, 100.0);
}

void sendTemperatureData() {
  Serial.println(">>> Sending Temperature Data to Server");
  
  DynamicJsonDocument doc(400);
  doc["device_id"] = DEVICE_ID;
  doc["timestamp"] = millis();
  doc["data_type"] = "temperature";
  doc["sampling_duration"] = SAMPLING_DURATION;
  doc["sample_count"] = tempSampleCount;
  
  // Maximum temperature data
  doc["temperature"] = round(maxTempC * 10.0) / 10.0;
  doc["temp_contact"] = true;
  doc["temp_status"] = "body_contact_detected";
  
  // System info
  doc["wifi_rssi"] = WiFi.RSSI();
  doc["uptime_ms"] = millis();
  doc["free_heap"] = ESP.getFreeHeap();
  
  String jsonString;
  serializeJson(doc, jsonString);
  
  Serial.printf("Sending Max Temperature: %.1f°C\n", maxTempC);
  if (sendHTTPRequest(jsonString)) {
    Serial.println("✓ Temperature data sent successfully");
  } else {
    Serial.println("✗ Failed to send temperature data");
  }
}

void sendFingerData() {
  Serial.println(">>> Sending Finger Data to Server");
  
  DynamicJsonDocument doc(400);
  doc["device_id"] = DEVICE_ID;
  doc["timestamp"] = millis();
  doc["data_type"] = "vitals";
  doc["sampling_duration"] = SAMPLING_DURATION;
  doc["sample_count"] = fingerSampleCount;
  
  // Maximum vitals data
  doc["spo2"] = round(maxSpO2 * 10.0) / 10.0;
  doc["heart_rate"] = maxHeartRate;
  doc["finger_detected"] = true;
  doc["vitals_status"] = "finger_detected";
  
  // System info
  doc["wifi_rssi"] = WiFi.RSSI();
  doc["uptime_ms"] = millis();
  doc["free_heap"] = ESP.getFreeHeap();
  
  String jsonString;
  serializeJson(doc, jsonString);
  
  Serial.printf("Sending Max SpO2: %.1f%%, Max HR: %d BPM\n", maxSpO2, maxHeartRate);
  if (sendHTTPRequest(jsonString)) {
    Serial.println("✓ Finger data sent successfully");
  } else {
    Serial.println("✗ Failed to send finger data");
  }
}

bool sendHTTPRequest(const String& jsonData) {
  HTTPClient http;
  bool success = false;
  
  http.begin(API_ENDPOINT_VITALS);
  http.setTimeout(HTTP_TIMEOUT);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("User-Agent", "ESP32-HealthMonitor/2.0");
  http.addHeader("Connection", "close");
  
  int httpResponseCode = http.POST(jsonData);
  
  if (httpResponseCode > 0) {
    String response = http.getString();
    
    if (httpResponseCode == 200 || httpResponseCode == 201) {
      Serial.printf("SUCCESS: Data sent (HTTP %d)\n", httpResponseCode);
      success = true;
      httpErrorCount = 0;
    } else {
      Serial.printf("WARNING: HTTP response code: %d\n", httpResponseCode);
      if (response.length() > 0 && response.length() < 200) {
        Serial.printf("Server response: %s\n", response.c_str());
      }
      httpErrorCount++;
      success = false;
    }
  } else {
    Serial.printf("ERROR: HTTP request failed with code: %d\n", httpResponseCode);
    httpErrorCount++;
    success = false;
  }
  
  http.end();
  return success;
}

void printCurrentStatus() {
  static unsigned long lastStatusPrint = 0;
  unsigned long currentTime = millis();
  
  // Print status every 2 seconds during normal operation
  if (currentTime - lastStatusPrint > 2000 && !tempSampling && !fingerSampling) {
    Serial.println("--- Current Status ---");
    
    if (tempContactDetected && tempValid) {
      Serial.printf("TEMP: %.1f°C (Body contact - Ready to sample)\n", tempC);
    } else if (tempC >= 10.0 && tempC < 30.0) {
      Serial.printf("TEMP: %.1f°C (Room temperature - No contact)\n", tempC);
    } else {
      Serial.printf("TEMP: %.1f°C (No contact detected)\n", tempC);
    }
    
    if (spo2Valid) {
      Serial.printf("VITALS: SpO2=%.1f%%, HR=%d BPM (Finger detected - Ready to sample)\n", spo2, heartRate);
    } else {
      Serial.println("VITALS: No finger detected");
    }
    
    if (wifiConnected) {
      Serial.printf("WiFi: Connected (RSSI: %d dBm)\n", WiFi.RSSI());
    } else {
      Serial.println("WiFi: Disconnected");
    }
    
    Serial.println("---------------------");
    lastStatusPrint = currentTime;
  }
}

void sendHeartbeat() {
  Serial.println("=== SYSTEM HEARTBEAT ===");
  Serial.printf("Uptime: %lu seconds\n", millis() / 1000);
  Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
  Serial.printf("WiFi: %s", wifiConnected ? "Connected" : "Disconnected");
  if (wifiConnected) {
    Serial.printf(" (RSSI: %d dBm)", WiFi.RSSI());
  }
  Serial.println();
  Serial.printf("MAX30105 sensor: %s\n", sensorOK ? "OK" : "ERROR");
  Serial.printf("LM35 sensor: %s\n", (tempC > 10.0 && tempC < 50.0) ? "OK" : "ERROR");
  Serial.printf("HTTP errors: %d\n", httpErrorCount);
  Serial.printf("Temp sampling: %s\n", tempSampling ? "ACTIVE" : "IDLE");
  Serial.printf("Finger sampling: %s\n", fingerSampling ? "ACTIVE" : "IDLE");
  Serial.printf("Temperature contact: %s\n", tempContactDetected ? "YES" : "NO");
  Serial.printf("Finger detection: %s\n", spo2Valid ? "YES" : "NO");
  Serial.println("========================");
}

void updateStatusLED() {
  static unsigned long lastLedUpdate = 0;
  static bool ledState = false;
  unsigned long currentTime = millis();
  
  if (currentTime - lastLedUpdate > 500) {  // Update every 500ms
    if (tempSampling || fingerSampling) {
      // Very fast blink during sampling
      digitalWrite(LED_PIN, ((currentTime / 100) % 2) ? HIGH : LOW);
    } else if (wifiConnected && (sensorOK || (tempC > 10.0 && tempC < 50.0))) {
      // Slow blink - all systems operational
      ledState = !ledState;
      digitalWrite(LED_PIN, ledState ? HIGH : LOW);
    } else if (wifiConnected) {
      // Fast blink - WiFi OK but sensor issues
      digitalWrite(LED_PIN, ((currentTime / 250) % 2) ? HIGH : LOW);
    } else {
      // Solid on - WiFi connection issues
      digitalWrite(LED_PIN, HIGH);
    }
    lastLedUpdate = currentTime;
  }
}

void handleCriticalError(const char* errorCode) {
  Serial.printf("CRITICAL ERROR: %s\n", errorCode);
  Serial.println("System will restart in 5 seconds...");
  
  // Blink LED rapidly to indicate critical error
  for (int i = 0; i < 10; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(250);
    digitalWrite(LED_PIN, LOW);
    delay(250);
  }
  
  Serial.println("Restarting ESP32...");
  ESP.restart();
}
